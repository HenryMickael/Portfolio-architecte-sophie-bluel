Pour stocker et réutiliser les données générées par le json() en dehors de sa fonction, vous pouvez déclarer une variable globale avant de définir la fonction json(). Dans cette fonction, vous pouvez affecter les données récupérées par json() à cette variable globale. Vous pourrez ensuite accéder à ces données depuis n'importe quelle autre partie de votre code.

Voici un exemple de code qui montre comment stocker les données récupérées par json() dans une variable globale nommée "apiData":

Copy code
let apiData;

fetch('http://localhost:5678/api/works')
    .then(response => response.json())
    .then(data => {
        apiData = data;
    });
Vous pouvez ensuite utiliser cette variable "apiData" pour filtrer les données en utilisant la fonction Array.filter() comme ceci:

Copy code
const filteredData = apiData.filter(item => item.category === 'Appartements');
Il est important de noter que l'accès à cette variable "apiData" ne sera possible qu'une fois que les données ont été récupérées et affectées à cette variable. Si vous avez besoin d'utiliser ces données immédiatement après la récupération, il est recommandé d'utiliser une fonction de rappel ou d'utiliser une bibliothèque asynchrone telle que async/await pour gérer l'asynchronisme.




Mickael Hny
explique moi et montre moi pour les deux
Il est possible de stocker les données générées par la fonction json() en utilisant une variable globale. Par exemple, vous pouvez déclarer une variable worksData en dehors de la fonction json() et y stocker les données récupérées à l'intérieur de cette fonction :

Copy code
let worksData;

fetch('http://localhost:5678/api/works')
  .then(response => response.json())
  .then(data => {
    worksData = data;
    // utilisez les données ici
  });
Il est également possible de retourner les données de la fonction json() et de les stocker dans une variable en utilisant la syntaxe async/await. Vous pouvez par exemple créer une fonction getWorksData qui appelle l'API et retourne les données :

Copy code
async function getWorksData() {
  const response = await fetch('http://localhost:5678/api/works');
  const data = await response.json();
  return data;
}

let worksData = await getWorksData();
Enfin, pour gerer les boutons filtres, vous pouvez utiliser un système de gestion de l'état pour stocker les informations sur le filtre actuellement sélectionné, et utiliser ces informations pour filtrer les données affichées. Vous pouvez utiliser des écouteurs d'événements sur les boutons pour mettre à jour cet état en fonction des boutons sélectionnés, puis utiliser cet état pour filtrer les données affichées.

Copy code
const filterButtons = document.querySelectorAll('.filter-button');
let currentFilter = 'all';

filterButtons.forEach(button => {
  button.addEventListener('click', event => {
    currentFilter = event.target.dataset.filter;
    updateDisplayedWorks();
  });
});

function updateDisplayedWorks() {
  let filteredData = worksData;
  if (currentFilter !== 'all') {
    filteredData = worksData.filter(work => work.category === currentFilter);
  }
  // Utilisez les données filtrées pour mettre à jour l'affichage
}
Notez que ceci est un exemple simplifié et qu'il peut y avoir des modifications à apporter selon la structure de vos données et la logique de votre application.